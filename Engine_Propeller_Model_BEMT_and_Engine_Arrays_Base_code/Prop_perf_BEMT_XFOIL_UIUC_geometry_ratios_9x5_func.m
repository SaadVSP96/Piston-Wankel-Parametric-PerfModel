%This code employs the BET to model the propeller efficiency and the
%thrust, torque and power generated by the propeller. The plan is to
%initially recreate the results given by the excel files created by
%S.Gudmundson and then proceed to replace the data by our own propeller
%The solution as prepared here breaks the propeller blades into 20 elements
%of equal width. Let’s begin the procedure by calculating some preliminaries:
function [Thrust, Torque, Power, C_T, C_Q, C_P, J, eeta_p] = ...
          Prop_perf_BEMT_XFOIL_UIUC_geometry_ratios_9x5_func...
          (altitude_ft, V_fwd_fts, RPM, Prop_dia_inch)
airfoil_dat_file = "ClarkY.dat";
%Establishing atmospheric Parameters
alt_ft = altitude_ft;%ft
alt_m = alt_ft * 0.3048;%m
%Temp in K, Sound Speed in m/s, Pressure in Pa, rho in kg/m3
[T_si,a_si,P_si,rho_si] = atmoscoesa(alt_m);
%converting atmospheric values to english units
T_eng = 1.8*T_si; %Temperature in English 
a = 3.28084*a_si; %speed of sound in english
P = 0.02088547*P_si;%Pressure in english
rho = 0.00194032*rho_si;%density in english
mew = ((-2.05e-09).*(alt_ft/1000)) + 3.739e-07;%Dynamic Viscoscity curvefit

%Basic Data
V_0_fts = V_fwd_fts;%mph to ft/s
a_alt = a;

%Preliminaries
n = RPM/60;%rps
Omega = 2*pi*(RPM/60);%rad/s
n_blades = 2;
%column 1 which was just serial id's is omitted since the set of
%stations and chords are available from the get go
% [r, R, c, Beta_deg] = Read_PropellerData_InFeet(propeller_file);
R = (Prop_dia_inch/2)/12;
r_by_R = [0.150000000000000,0.200000000000000,0.250000000000000,0.300000000000000,0.350000000000000,0.400000000000000,0.450000000000000,0.500000000000000,0.550000000000000,0.600000000000000,0.650000000000000,0.700000000000000,0.750000000000000,0.800000000000000,0.850000000000000,0.900000000000000,0.950000000000000,1];
c_by_R = [0.169000000000000,0.181000000000000,0.183000000000000,0.183000000000000,0.182000000000000,0.180000000000000,0.176000000000000,0.173000000000000,0.170000000000000,0.167000000000000,0.162000000000000,0.156000000000000,0.150000000000000,0.142000000000000,0.132000000000000,0.117000000000000,0.0950000000000000,0.0730000000000000];
Beta_deg = [25.6500000000000,26.3500000000000,26.7500000000000,26.4900000000000,25.5700000000000,23.9500000000000,21.7200000000000,19.3800000000000,17.5300000000000,15.8000000000000,14.4000000000000,13.1900000000000,12.0900000000000,11.3800000000000,10.1300000000000,8.70000000000000,6.50000000000000,4.26000000000000];
r = R*r_by_R;
c = R*c_by_R;
Dia_prop = (R*12)*2;%inches
Dia_hub = (r_by_R(1)*R)*12*2;%inches
R_hub = (Dia_hub/2)*(1/12);%ft
no_elements = length(r);%no. of elements the prop is divided in
%Column 3 is calculated to allow plotting of results with respect to the 
%fraction of the blade span
x = r./R;
%Column 4 is the chord at the radial
%Column 5 is the area of the blade element
for i = 1:1:(no_elements)
    %Column 5 is the area of the blade element
    if i == 1
        del_r(i) = r(i) - R_hub;
    elseif i ~= 1
        del_r(i) = r(i) - r(i-1);
    end
    del_A(i) = c(i)*del_r(i);
    %Column 6 is the forward speed (i.e. the airplane’s airspeed) converted to 
    %ft/s and is equal for all the rows
    V_o(i) = V_0_fts;
    %Column 7 is the blade’s tangential rotational speed at that segement
    Omega_x_r(i) = Omega*r(i);
    %Column 8 is the resultant velocity for each segment that combines rotation
    %and forward speed
    V_R(i) = sqrt((V_o(i)^2)+(Omega_x_r(i)^2));
    %Column 9 is the Mach Number for each blade segement - some differences may
    %occur due to inaccuracies in the density or a matrices
    M(i) = V_R(i)/a_alt;
    %Columns 10 and 11 contain the helix angle in radians and degrees
    phi_rad(i) = atan(V_o(i)/Omega_x_r(i));
    phi_deg(i) = rad2deg(phi_rad(i)); 
    %Columns 14 and 15 contain the geometric pitch angle B which is specified
    %in the file
    Beta_rad(i) = deg2rad(Beta_deg(i));
    %Columns 16 and 17 contain the AOA of the airfoil.
    Re(i) = (rho*V_R(i)*c(i))/mew;
    [alpha_zl_deg(i), ~] = XFoil_Analysis_alpha_0_lift(M(i), Re(i), 0.0 , airfoil_dat_file);
    alpha_zl_rad(i) = deg2rad(alpha_zl_deg(i));
end
%now we need the AOA at each segment and of course that uses the formula:
%alpha = Beta - phi - alpha_i + alpha_ZL
%now in the example, it has been stated that the example propeller uses a
%single airfoil and so the zero lift AOA will remain the same trough out
%however we will probably have a more complicated scenario with different
%airfoils at different segments and thereby causing different zerolift
%AOAs, in which case, a set will have to be populated for this manually:
%for now use the sigular example value in all positions
%Column 18 contains the Reynolds number for the blade elements
%for now the assumption is that the prop is made out of a single airfoil,
%that probably wont be the case in reality thereby making it a necessity to
%have a lift and drag equation for every different airfoil used in the prop
%and then access it at the respective section's AOA against the AOA at that
%section.
%Columns 19 and 20 will contain the C_l and C_d values of the airfoil
%section of the segment in question against the Alpha calculated apriori. 
%Columns 21 and 22 contain the differential lift and drag acting on element 
w(1:no_elements,1) = 1;%ft/s
alpha_deg(1:no_elements,1) = 7.143;%deg;
alpha_rad(1:no_elements,1) = deg2rad(alpha_deg(1:no_elements,1));%rad

% Entering Values for Boundary Layer Behavior:
Xtrip_c_top = [1, 1, 1];
Xtrip_c_bottom = [1, 1, 1];
Ncrit = [9, 7.3, 2.4]; %moving from high to low Re nummbers
vacc = [0.01, 0.023, 0.0075]; %moving from high to low Re nummbers
% starting the loops:
for i = 1:1:(no_elements)
    for j = 1:1:5
        V_E(i,j) = sqrt(((w(i,j)+V_0_fts)^2)+(Omega_x_r(i)^2));
        try 
            if i <= 18
                [C_l(i,j), C_d(i,j)] = XFoil_Analysis_new(M(i), Re(i), alpha_deg(i,j),...
                 airfoil_dat_file, Xtrip_c_top(1), Xtrip_c_bottom(1), Ncrit(1), vacc(1));
            elseif (i > 18) && (i <= 20) 
                [C_l(i,j), C_d(i,j)] = XFoil_Analysis_new(M(i), Re(i), alpha_deg(i,j),...
                 airfoil_dat_file, Xtrip_c_top(2), Xtrip_c_bottom(2), Ncrit(2), vacc(2));
            elseif i > 20
                [C_l(i,j), C_d(i,j)] = XFoil_Analysis_new(M(i), Re(i), alpha_deg(i,j),...
                 airfoil_dat_file, Xtrip_c_top(3), Xtrip_c_bottom(3), Ncrit(3), vacc_2(j));
                
            end
        catch
            C_l(i,j) = C_l(i,j-1);
            C_d(i,j) = C_d(i,j-1);
        end
        f_w(i,j) = (((8*pi*r(i))/(n_blades*c(i)))*w(i,j))-((V_E(i,j)/...
        (V_0_fts+w(i,j)))*(C_l(i,j)*Omega_x_r(i))-(C_d(i,j)*(w(i,j)*V_0_fts)));
    
        f_prime_w(i,j) = ((8*pi*r(i))/(n_blades*c(i))) - (((C_l(i,j)...
        *Omega_x_r(i)))*((1/V_E(i,j))-(V_E(i,j)/((V_0_fts+w...
        (i,j))^2)))) + (C_d(i,j)*((w(i,j)*V_0_fts)/(V_E(i,j))));
    
        w(i,j+1) = w(i,j) - ((f_w(i,j))/(f_prime_w(i,j)));
        
        diff(i,j) = w(i,j+1) - w(i,j);
        
        alpha_i_rad(i,j) = atan(w(i,j)/V_E(i,j));  
        alpha_i_deg(i,j) = rad2deg(alpha_i_rad(i,j));
        
        alpha_rad(i,j+1) = Beta_rad(i)-phi_rad(i)-alpha_i_rad(i,j)+alpha_zl_rad(i);
        alpha_deg(i,j+1) = rad2deg(alpha_rad(i,j+1));
    end
    C_l(i) = C_l(i,end);
    C_d(i) = C_d(i,end);
    d_L(i) = 0.5*rho*V_E(i,end)*V_E(i,end)*c(i)*C_l(i)*del_r(i);
    d_D(i) = 0.5*rho*V_E(i,end)*V_E(i,end)*c(i)*C_d(i)*del_r(i);
end
for i = 1:1:(no_elements)
    %defining the prandtl tip and hub loss corrections
    d_T(i) = ((d_L(i)*cos(phi_rad(i)+alpha_i_rad(i,end))) - ...
    (d_D(i)*sin(phi_rad(i)+alpha_i_rad(i,end))));
    d_Q(i) = (r(i)*((d_L(i)*sin(phi_rad(i)+alpha_i_rad(i,end)))+(d_D(i)*cos...
    (phi_rad(i)+alpha_i_rad(i,end)))));
    d_P(i) = (Omega_x_r(i)*((d_L(i)*sin(phi_rad(i)+alpha_i_rad(i,end)))+...
    (d_D(i)*cos(phi_rad(i)+alpha_i_rad(i,end)))));
end
%Total values
Thrust = n_blades*sum(d_T);
Torque = n_blades*sum(d_Q);
Power = n_blades*sum(d_P);

%Coefficients
C_P = Power/(rho*(n^3)*((Dia_prop/12)^5));
C_T = Thrust/(rho*(n^2)*((Dia_prop/12)^4));
C_Q = Torque/(rho*(n^2)*((Dia_prop/12)^5));

%prop efficiency calculation
J = V_0_fts/(n*(Dia_prop/12));
eeta_p = J*(C_T/C_P);
end
